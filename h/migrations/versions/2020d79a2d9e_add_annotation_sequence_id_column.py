"""Add the annotation.sequence_id column."""
import datetime

import sqlalchemy as sa
from alembic import op
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.schema import CreateSequence, DropSequence

revision = "2020d79a2d9e"
down_revision = "64039842150a"


Base = declarative_base()

sequence_id_sequence = sa.Sequence(
    "annotation_sequence_id_seq",
    metadata=Base.metadata,
    # Start the sequence counting from 15 million.
    #
    # This is because the sequence is only going to be used to generate
    # sequence_id's for *new* rows that get added to the annotation table after
    # this DB migration has run. We're going to have to write a background task
    # to slowly backfill the sequence_id's for the *preexisting* rows without
    # locking the DB. We need roughly sequence values 0-14M for that
    # backfilling (the production DB contains almost 14M annotations at the
    # time of writing) so the autogenerated sequence values need to start at
    # something higher than 14M. 15M should give us plenty of headroom.
    start=15000000,
)


def upgrade():
    # We first add the column *without* a server_default.
    #
    # This is because, if we added the column with the server_default, Postgres
    # would automatically backfill the column for all existing rows in the
    # annotation table with sequence numbers and, since the annotation table
    # has a lot of rows in it, this would lock the table for a long time and
    # cause an outage.
    #
    # Adding the column without the server_default causes all existing rows to
    # get null values in the column, which takes no significant amount of time.
    op.add_column(
        "annotation",
        sa.Column(
            "sequence_id", sa.Integer, op.execute(CreateSequence(sequence_id_sequence)),
        ),
    )

    # Next, we add the server_default so that any new rows that get added to
    # the column in future will get auto-generated sequence_id's.
    #
    # Postgres does not backfill the existing rows in the table when you use an
    # alter_column() to add a server_default to an already-existing column
    # because those existing rows already have values in the sequence_id column
    # and Postgres doesn't want to overwrite those existing values (not even if
    # the values are null).
    op.alter_column(
        "annotation",
        "sequence_id",
        server_default=sa.text("nextval('annotation_sequence_id_seq'::regclass)"),
    )


def downgrade():
    op.drop_column("annotation", "sequence_id")
    op.execute(DropSequence(sequence_id_sequence))
