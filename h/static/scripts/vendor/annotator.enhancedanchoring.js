// Generated by CoffeeScript 1.6.3
/*
** Annotator 1.2.6-dev-e2bea2d
** https://github.com/okfn/annotator/
**
** Copyright 2012 Aron Carroll, Rufus Pollock, and Nick Stenning.
** Dual licensed under the MIT and GPLv3 licenses.
** https://github.com/okfn/annotator/blob/master/LICENSE
**
** Built at: 2015-01-17 12:44:26Z
*/



/*
//
*/

// Generated by CoffeeScript 1.6.3
(function() {
  var Anchor, DummyDocumentAccess,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DummyDocumentAccess = (function() {
    function DummyDocumentAccess() {}

    DummyDocumentAccess.applicable = function() {
      return true;
    };

    DummyDocumentAccess.prototype.getPageIndex = function() {
      return 0;
    };

    DummyDocumentAccess.prototype.getPageCount = function() {
      return 1;
    };

    DummyDocumentAccess.prototype.getPageIndexForPos = function() {
      return 0;
    };

    DummyDocumentAccess.prototype.isPageMapped = function() {
      return true;
    };

    DummyDocumentAccess.prototype.scan = function() {};

    return DummyDocumentAccess;

  })();

  Anchor = (function() {
    function Anchor(anchoring, annotation, target, startPage, endPage, quote, diffHTML, diffCaseOnly) {
      this.anchoring = anchoring;
      this.annotation = annotation;
      this.target = target;
      this.startPage = startPage;
      this.endPage = endPage;
      this.quote = quote;
      this.diffHTML = diffHTML;
      this.diffCaseOnly = diffCaseOnly;
      this.virtualize = __bind(this.virtualize, this);
      this.realize = __bind(this.realize, this);
      if (this.anchoring == null) {
        throw "anchoring manager is required!";
      }
      if (this.annotation == null) {
        throw "annotation is required!";
      }
      if (this.target == null) {
        throw "target is required!";
      }
      if (this.startPage == null) {
        "startPage is required!";
      }
      if (this.endPage == null) {
        throw "endPage is required!";
      }
      if (this.quote == null) {
        throw "quote is required!";
      }
      this.highlight = {};
    }

    Anchor.prototype._getSegment = function(page) {
      throw "Function not implemented";
    };

    Anchor.prototype.realize = function() {
      var created, page, pagesTodo, renderedPages, _i, _ref, _ref1, _results,
        _this = this;
      if (this.fullyRealized) {
        return;
      }
      renderedPages = (function() {
        _results = [];
        for (var _i = _ref = this.startPage, _ref1 = this.endPage; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).filter(function(index) {
        return _this.anchoring.document.isPageMapped(index);
      });
      pagesTodo = renderedPages.filter(function(index) {
        return _this.highlight[index] == null;
      });
      if (!pagesTodo.length) {
        return;
      }
      created = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = pagesTodo.length; _j < _len; _j++) {
          page = pagesTodo[_j];
          _results1.push(this.highlight[page] = this.Annotator.TextHighlight.createFrom(this._getSegment(page), this, page));
        }
        return _results1;
      }).call(this);
      this.fullyRealized = renderedPages.length === this.endPage - this.startPage + 1;
      return this.anchoring.annotator.publish('highlightsCreated', created);
    };

    Anchor.prototype.virtualize = function(pageIndex) {
      var highlight;
      highlight = this.highlight[pageIndex];
      if (highlight == null) {
        return;
      }
      highlight.removeFromDocument();
      delete this.highlight[pageIndex];
      this.fullyRealized = false;
      return this.anchoring.annotator.publish('highlightRemoved', highlight);
    };

    Anchor.prototype.remove = function() {
      var anchors, i, index, _i, _ref, _ref1, _ref2, _results;
      _results = [];
      for (index = _i = _ref = this.startPage, _ref1 = this.endPage; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; index = _ref <= _ref1 ? ++_i : --_i) {
        this.virtualize(index);
        anchors = this.anchoring.anchors[index];
        i = anchors.indexOf(this);
        [].splice.apply(anchors, [i, i - i + 1].concat(_ref2 = [])), _ref2;
        if (!anchors.length) {
          _results.push(delete this.anchoring.anchors[index]);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Anchor.prototype.annotationUpdated = function() {
      var index, _i, _ref, _ref1, _ref2, _results;
      _results = [];
      for (index = _i = _ref = this.startPage, _ref1 = this.endPage; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; index = _ref <= _ref1 ? ++_i : --_i) {
        _results.push((_ref2 = this.highlight[index]) != null ? _ref2.annotationUpdated() : void 0);
      }
      return _results;
    };

    return Anchor;

  })();

  Annotator.Anchor = Anchor;

  Annotator.Plugin.EnhancedAnchoring = (function(_super) {
    __extends(EnhancedAnchoring, _super);

    function EnhancedAnchoring() {
      this.getSelectorsFromSelection = __bind(this.getSelectorsFromSelection, this);
    }

    EnhancedAnchoring.prototype._setupDocumentAccessStrategies = function() {
      this.documentAccessStrategies = [
        {
          name: "Dummy",
          mapper: DummyDocumentAccess
        }
      ];
      return this;
    };

    EnhancedAnchoring.prototype._setupAnchorEvents = function() {
      var _this = this;
      return this.annotator.on('annotationUpdated', function(annotation) {
        var anchor, _i, _len, _ref, _results;
        _ref = annotation.anchors || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          anchor = _ref[_i];
          _results.push(anchor.annotationUpdated());
        }
        return _results;
      });
    };

    EnhancedAnchoring.prototype._chooseAccessPolicy = function() {
      var s, _i, _len, _ref,
        _this = this;
      if (this.document != null) {
        return;
      }
      _ref = this.documentAccessStrategies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (s.mapper.applicable()) {
          this.documentAccessStrategy = s;
          this.document = new s.mapper();
          this.anchors = {};
          addEventListener("docPageMapped", function(evt) {
            return _this._realizePage(evt.pageIndex);
          });
          addEventListener("docPageUnmapped", function(evt) {
            return _this._virtualizePage(evt.pageIndex);
          });
          if (typeof s.init === "function") {
            s.init();
          }
          return this;
        }
      }
    };

    EnhancedAnchoring.prototype._removeCurrentAccessPolicy = function() {
      var index, list, _base;
      if (this.document == null) {
        return;
      }
      list = this.documentAccessStrategies;
      index = list.indexOf(this.documentAccessStrategy);
      if (index !== -1) {
        list.splice(index, 1);
      }
      if (typeof (_base = this.document).destroy === "function") {
        _base.destroy();
      }
      return delete this.document;
    };

    EnhancedAnchoring.prototype._scan = function() {
      this._chooseAccessPolicy();
      try {
        return this.pendingScan = this.document.scan();
      } catch (_error) {
        this._removeCurrentAccessPolicy();
        this._scan();
      }
    };

    EnhancedAnchoring.prototype.pluginInit = function() {
      this.$ = Annotator.$;
      this.selectorCreators = [];
      this.strategies = [];
      this._setupDocumentAccessStrategies();
      this._setupAnchorEvents();
      return this.annotator.anchoring = this;
    };

    EnhancedAnchoring.prototype.createAnchor = function(annotation, target) {
      var a, anchor, error, pageIndex, s, _base, _i, _j, _len, _ref, _ref1, _ref2, _ref3;
      if (target == null) {
        throw new Error("Trying to find anchor for null target!");
      }
      error = null;
      anchor = null;
      _ref = this.strategies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        try {
          a = s.code.call(this, annotation, target);
          if (a) {
            for (pageIndex = _j = _ref1 = a.startPage, _ref2 = a.endPage; _ref1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; pageIndex = _ref1 <= _ref2 ? ++_j : --_j) {
              if ((_base = this.anchors)[pageIndex] == null) {
                _base[pageIndex] = [];
              }
              this.anchors[pageIndex].push(a);
            }
            a.realize();
            return {
              result: a
            };
          }
        } catch (_error) {
          error = _error;
          console.log("Strategy '" + s.name + "' has thrown an error.", (_ref3 = error.stack) != null ? _ref3 : error);
        }
      }
      return {
        error: "No strategies worked."
      };
    };

    EnhancedAnchoring.prototype.normalizeString = function(string) {
      return string.replace(/\s{2,}/g, " ");
    };

    EnhancedAnchoring.prototype.findSelector = function(selectors, type) {
      var selector, _i, _len;
      for (_i = 0, _len = selectors.length; _i < _len; _i++) {
        selector = selectors[_i];
        if (selector.type === type) {
          return selector;
        }
      }
      return null;
    };

    EnhancedAnchoring.prototype._realizePage = function(index) {
      var anchor, _i, _len, _ref, _ref1, _results;
      if (!this.document.isPageMapped(index)) {
        return;
      }
      _ref1 = (_ref = this.anchors[index]) != null ? _ref : [];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        anchor = _ref1[_i];
        _results.push(anchor.realize());
      }
      return _results;
    };

    EnhancedAnchoring.prototype._virtualizePage = function(index) {
      var anchor, _i, _len, _ref, _ref1, _results;
      _ref1 = (_ref = this.anchors[index]) != null ? _ref : [];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        anchor = _ref1[_i];
        _results.push(anchor.virtualize(index));
      }
      return _results;
    };

    EnhancedAnchoring.prototype.getHighlights = function(annotations) {
      var anchor, anchors, annotation, hl, page, results, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      results = [];
      if (annotations != null) {
        for (_i = 0, _len = annotations.length; _i < _len; _i++) {
          annotation = annotations[_i];
          _ref = annotation.anchors;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            anchor = _ref[_j];
            _ref1 = anchor.highlight;
            for (page in _ref1) {
              hl = _ref1[page];
              results.push(hl);
            }
          }
        }
      } else {
        _ref2 = this.anchors;
        for (page in _ref2) {
          anchors = _ref2[page];
          this.$.merge(results, (function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = anchors.length; _k < _len2; _k++) {
              anchor = anchors[_k];
              if (anchor.highlight[page] != null) {
                _results.push(anchor.highlight[page]);
              }
            }
            return _results;
          })());
        }
      }
      return results;
    };

    EnhancedAnchoring.prototype.getSelectorsFromSelection = function(selection) {
      var c, description, selector, selectors, _i, _j, _len, _len1, _ref;
      selectors = [];
      _ref = this.selectorCreators;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        description = c.describe(selection);
        for (_j = 0, _len1 = description.length; _j < _len1; _j++) {
          selector = description[_j];
          selectors.push(selector);
        }
      }
      return selectors;
    };

    return EnhancedAnchoring;

  })(Annotator.Plugin);

}).call(this);

//
//# sourceMappingURL=annotator.enhancedanchoring.map